# Application Security Setup

This document outlines the authentication and security mechanisms implemented in the application.

## 1. Overall Security Mechanism

The application employs Spring Security framework, utilizing a combination of:
- **One-Time Password (OTP) Authentication:** For initial user verification.
- **JSON Web Tokens (JWT):** For authenticating subsequent API requests after the initial OTP verification.
- **Stateless Sessions:** API interactions are stateless, relying on JWTs for session information.

## 2. Authentication Flow

The authentication process is primarily managed by `AuthenticationController` and supporting services (`UserService`, `VisionAmbassadorService`).

1.  **OTP Request:**
    *   A user initiates login by sending their phone number (via `AuthenticationRequest` DTO) to an OTP request endpoint.
    *   **Endpoints:**
        *   `POST /auth/vision-ambassador-rquest-otp`: Specifically for Vision Ambassadors.
        *   `POST /auth/request-otp`: For general users or Vision Ambassadors (differentiated by a query parameter `visionAmbassador`).
    *   The backend service (e.g., `UserService`) generates an OTP, stores it (likely in the `UserSession` collection, associated with a generated session ID), and sends the OTP to the user's registered phone number (the exact sending mechanism like SMS gateway integration is outside the scope of the provided code).
    *   An `AuthenticationResponse` DTO, containing the `sessionId`, is returned to the client.

2.  **OTP Verification:**
    *   The user submits the received OTP along with the `sessionId` to the verification endpoint.
    *   **Endpoint:** `POST /auth/verify-otp` (using `OTPVerificationRequest` DTO).
    *   The backend service (`UserService.verifyOTP`) validates the submitted OTP against the one stored for the given `sessionId`.

3.  **JWT Generation:**
    *   Upon successful OTP verification, the `UserService.verifyOTP` method calls `JWTTokenProvider.generateToken(userDetails)` to create a JWT.
    *   This JWT is then returned to the client within an `OTPVerificationResponse` DTO. This token is used for authorizing subsequent API requests.

4.  **OTP Resend:**
    *   If a user doesn't receive an OTP, they can request it again.
    *   **Endpoint:** `POST /auth/resend-otp` (using `OTPResendRequest` DTO containing the `sessionId`).
    *   The backend (`UserService.resendOTP`) generates a new OTP for the session and (presumably) resends it. A new `sessionId` (or the same one refreshed) is returned in `OTPResendResponse`.

## 3. JWT Usage

### Generation:
-   JWTs are generated by the `JWTTokenProvider.generateToken()` method.
-   **Process:**
    1.  Takes `UserDetails` (and optional extra claims) as input.
    2.  Sets standard claims:
        *   `sub` (subject): User's username (which is the User's MongoDB ObjectId as a String).
        *   `iat` (issued at): Current timestamp.
        *   `exp` (expiration): Current timestamp + configured expiration time (`jwt.expiration` property).
    3.  Can include custom claims (e.g., `userId`, `role`, `email`, `phone`, `name` as seen in `JWTTokenProvider` extraction methods, though the population of these claims during generation isn't explicitly shown in `generateToken` but is a common practice).
    4.  Signs the token using HMAC-SHA256 algorithm (`SignatureAlgorithm.HS256`) with a base64 encoded secret key (`jwt.secret` property).

### Validation:
-   JWT validation is primarily handled by `JwtAuthenticationFilter` in conjunction with `JWTTokenProvider`.
-   **Process:**
    1.  `JwtAuthenticationFilter` intercepts incoming HTTP requests.
    2.  It extracts the token from the `Authorization` header (expecting "Bearer <token>").
    3.  If a token is found, it's passed to `JWTTokenProvider.validateToken(token, userDetails)`.
    4.  `JWTTokenProvider.validateToken()`:
        *   Extracts the username from the token using `extractUsername()`.
        *   Checks if the extracted username matches `userDetails.getUsername()`.
        *   Checks if the token is expired using `isTokenExpired()`.
    5.  `JWTTokenProvider.extractAllClaims()` parses the token using the configured signing key to retrieve all claims. If parsing fails (e.g., invalid signature, malformed token), an exception is thrown, and validation fails.

### SecurityContextHolder Population:
-   If the JWT is successfully validated by `JwtAuthenticationFilter`:
    1.  `UserDetails` are loaded using `UserDetailsService.loadUserByUsername()`.
    2.  A `UsernamePasswordAuthenticationToken` is created with these `UserDetails`, `null` credentials (as JWT is the credential), and the authorities from `UserDetails`.
    3.  This `authentication` token is then set in the `SecurityContextHolder`: `SecurityContextHolder.getContext().setAuthentication(authentication)`.
    - This makes the authenticated user's principal and authorities available throughout the request processing chain.

## 4. Key Security Classes and Their Roles

-   **`SecurityConfig.java`:**
    *   **Role:** Central class for Spring Security configuration.
    *   **Setup:**
        *   Uses `@EnableWebSecurity` and `@EnableMethodSecurity`.
        *   Configures CORS.
        *   Disables CSRF protection (`csrf -> csrf.disable()`).
        *   **Authorization Rules:** Currently, it permits all requests: `auth.requestMatchers("/**").permitAll()`. **This is a critical security misconfiguration for a production environment and should be reviewed to implement appropriate access controls for different endpoints based on roles or permissions.**
        *   Sets session management to `SessionCreationPolicy.STATELESS`.
        *   Defines an `AuthenticationManager` (using `DaoAuthenticationProvider`).
        *   The `DaoAuthenticationProvider` is configured with `ApplicationUserDetailsService` and `PasswordEncoder`.
        *   Adds `JwtAuthenticationFilter` into the filter chain before `UsernamePasswordAuthenticationFilter`.

-   **`JwtAuthenticationFilter.java`:**
    *   **Role:** Intercepts HTTP requests to perform JWT-based authentication.
    *   **Functionality:**
        *   Extends `OncePerRequestFilter`.
        *   Extracts JWT from the "Authorization: Bearer" header.
        *   If a token is present, it uses `JWTTokenProvider` to validate it and extract the username.
        *   Loads `UserDetails` via `ApplicationUserDetailsService`.
        *   If the token is valid, it populates the `SecurityContextHolder` with an `UsernamePasswordAuthenticationToken`.
        *   Includes an `excludedPaths` configuration (`auth.excluded.path` property) to bypass filtering for specified paths (e.g., `/auth/**` endpoints).

-   **`JWTTokenProvider.java`:**
    *   **Role:** Utility class for all JWT-related operations.
    *   **Functionality:**
        *   Generates JWTs with specified claims, subject, issuance/expiration dates, and signature.
        *   Validates JWTs by verifying the signature and checking expiration.
        *   Extracts claims (username, custom claims like userId, role, etc.) from a token.
        *   Uses configurable `jwt.secret` and `jwt.expiration` values.

-   **`ApplicationUserDetailsService.java`:**
    *   **Role:** Implements Spring Security's `UserDetailsService`.
    *   **Functionality:**
        *   The `loadUserByUsername(String username)` method is responsible for fetching user details. In this application, `username` is the User's MongoDB ObjectId as a String.
        *   It retrieves the `com.nayonikaeyecare.api.entities.user.User` entity from the `UserRepository`.
        *   **Crucially, it currently constructs a Spring Security `User` object with an empty password and no authorities: `new User(user.getId().toString(), "", Collections.emptyList())`. This means that while the user is identified, standard Spring Security role/permission checks based on `GrantedAuthority` will not work out-of-the-box.**

-   **`PasswordEncoderConfig.java` (and `PasswordEncoder` bean):**
    *   **Role:** Provides a `PasswordEncoder` instance (specifically `BCryptPasswordEncoder`).
    *   **Usage:** This encoder is wired into the `DaoAuthenticationProvider`. In a traditional setup, it's used to compare a submitted password with a hashed password from the database. In this OTP-based system:
        *   It's not directly used for OTP verification against a stored hash by `DaoAuthenticationProvider` because `ApplicationUserDetailsService` provides an empty password for the `UserDetails`.
        *   The OTPs are likely stored in plain text or a reversible format in `UserCredential.secret` for the `UserService` to directly compare, or the `secret` field is unused and OTPs are only transient. If OTPs were hashed in `UserCredential.secret`, `UserService` would need to use this encoder for comparison, not `DaoAuthenticationProvider`.
        *   The presence of `PasswordEncoder` is standard for Spring Security but its role in the OTP flow is indirect.

## 5. Authorization

-   **Current State:**
    *   As per `SecurityConfig.java`, all HTTP requests are currently permitted: `.requestMatchers("/**").permitAll()`. **This means there is effectively no endpoint authorization enforced by Spring Security at the moment, which is a significant security risk.** This configuration should be changed to secure endpoints appropriately.
-   **RBAC/Permission Features:**
    *   The data model includes entities for `Role` (`@Document("roles")`) and `Permission` (`@Document("permissions")`).
        *   `User` entity has a `List<Permission> permissions` field.
        *   `Role` entity has a `List<Permission> permissions` field.
        *   `Permission` entity has a `List<Role> roles` field, suggesting a many-to-many relationship if fully utilized.
    *   This indicates an **intention** to support fine-grained, permission-based access control, potentially organized via roles.
    *   **However, this is not currently integrated into Spring Security's authorization mechanism.** The `UserDetails` loaded by `ApplicationUserDetailsService` do not include any `GrantedAuthority`s derived from these roles or permissions.
    *   To make this functional, `ApplicationUserDetailsService` would need to be updated to convert the User's roles/permissions into `GrantedAuthority` objects. Then, `SecurityConfig` could use these authorities for endpoint protection (e.g., `http.authorizeHttpRequests(auth -> auth.requestMatchers("/admin/**").hasAuthority("PERMISSION_XYZ"))`) or method-level security with `@PreAuthorize`.
    *   Alternatively, authorization logic might be implemented custom within service methods by manually checking user permissions after extracting them from the JWT or user object.

## 6. Session Management

-   Session management is configured as **`STATELESS`** in `SecurityConfig.java`:
    `sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))`
-   This is appropriate for APIs secured with JWTs, as each request carries its own authentication information (the JWT), and no session state is maintained on the server between requests.

## 7. CSRF Protection

-   Cross-Site Request Forgery (CSRF) protection is **disabled** in `SecurityConfig.java`:
    `csrf(csrf -> csrf.disable())`
-   This is a common practice for stateless APIs where:
    *   Authentication is not based on session cookies (which CSRF attacks typically exploit).
    *   Clients (especially non-browser clients) might not be able to handle CSRF tokens easily.
-   If the API is only accessed by JavaScript from the same domain (or properly configured CORS domains), and JWTs are stored securely (e.g., HttpOnly cookies are not the primary JWT transmission method for SPA interaction due to XSS risks, and local storage has its own considerations), disabling CSRF for a stateless API can be acceptable. However, the overall security posture, including XSS prevention, must be strong.

---

**Recommendations:**
-   **Urgently review and update the authorization rules in `SecurityConfig.java`**. The current `permitAll()` for all paths is insecure. Implement role-based or permission-based authorization for endpoints.
-   **Integrate Roles/Permissions into `UserDetails`:** Modify `ApplicationUserDetailsService` to load the user's assigned roles and/or permissions and convert them into `GrantedAuthority` objects. This will enable the use of Spring Security's standard authorization annotations and configuration.
-   **Clarify OTP Storage:** Determine if OTPs (or secrets related to them) are stored, and if so, ensure they are stored securely (e.g., hashed if they are long-lived, though OTPs are typically short-lived). The current `PasswordEncoder` is available if hashing is needed.
-   **Review JWT Claims:** Ensure all necessary user information for authorization decisions (like roles or permissions) is included as claims in the JWT if planning to use a decentralized authorization check model, or ensure the JWT subject (userId) is sufficient to reload these details efficiently.Okay, I have analyzed all the provided files and have a comprehensive understanding of the security setup. I will now generate the `security_setup.md` document.
